<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  <meta name="referrer" content="unsafe-url">
  <div class="head">
  
  <title>前序+中序构造二叉树(review一下几种遍历)</title>
  <meta name="author" content="hhlsdhh">
  <meta name="description" content="to the leetcode
本题 -&amp;gt; 根据给出的前序和中序遍历顺序，来构造二叉树。我认为二叉树这类题都是大同小异的，变来变去就是在四种遍历(前序、中序、后序、层序)的基础上进行一些操作。
刚刚读了一篇关于这四种遍历的博客，突然一下感觉豁然开朗哈哈哈哈哈【之前做二叉树的题都是直接套模板，f">
  
  
  <meta property="og:title" content="前序+中序构造二叉树(review一下几种遍历)"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="小刘&#39;s blog"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="小刘&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="stylesheet" href="/css/head.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  </div>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="main-ctnr">
      <div class="behind">
  <a href="/" class="back black-color">
    <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
        <path d="M2 30 L30 2 M30 30 L2 2"></path>
    </svg>
  </a>
  
</div>


  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        前序+中序构造二叉树(review一下几种遍历)
    </h1>
  


    </div>
    <div class="meta center">
      <time datetime="2024-03-06T08:23:00.000Z" itemprop="datePublished">
  <svg class="i-calendar" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2024-03-06
</time>


    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/categories/leetcode/">leetcode</a>





    </div>
    <hr>
    
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E6%9C%AC%E9%A2%98"><span class="toc-text">回到本题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">代码如下：</span></a></li></ol>
    
    <div class="picture-container">
      
    </div>
    <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">to the leetcode</a></p>
<p>本题 -&gt; 根据给出的前序和中序遍历顺序，来构造二叉树。我认为二叉树这类题都是大同小异的，变来变去就是在四种遍历(前序、中序、后序、层序)的基础上进行一些操作。</p>
<p>刚刚读了一篇关于这四种遍历的博客，突然一下感觉豁然开朗哈哈哈哈哈【之前做二叉树的题都是直接套模板，for example：需要前序遍历解决问题就 some操作—&gt; dfs(node.left) -&gt; dfs(node.right) ；中序遍历就 dfs(node.left) -&gt; some操作 —&gt;  dfs(node.right) ；那后续遍历就  dfs(node.left) -&gt; dfs(node.right) -&gt; some操作 】然后咱们就是转述一下这篇博客的大概内容哈：</p>
<p><img src="/static/images/%E9%81%8D%E5%8E%861.jpg" alt="哦豁，没加载出来"></p>
<p>如上图所示，我们把叶子节点的左右孩子节点(为null)也加上，就不难看出，在我们围绕该二叉树的外围走一圈的过程中，如果把每一步都画上带有 direction 的箭头，那么除了根节点和为 null 的节点，其余节点都会有三个箭头指向自己！分别来自自己的<strong>父亲节点</strong> 、<strong>左孩子</strong>、<strong>右孩子</strong>。也就是说没个节点都被经过访问了三次，也就对应了<strong>前、中、后</strong>三种遍历！</p>
<p>其实我们写的三种遍历的程序，都是按照绕着二叉树外围跑一圈的顺序来对其进行遍历的，<strong>区别在</strong> 对于每个结点，我选择在<strong>第几次访问它们的时候</strong>对它们执行某些操作(或打印或其他….)</p>
<p><a target="_blank" rel="noopener" href="http://www.hangdaowangluo.com/archives/2979">博客详情</a></p>
<h4 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h4><p><img src="/static/images/%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0.jpg" alt="哦豁，没加载出来"></p>
<p>;给出了前序和中序遍历的结果，根据它们构造对应的二叉树。我们平常用笔画二叉树的时候，一般也是先画根节点，再画左右孩子节点的哈，那其实构建顺序就是 根-&gt;左-&gt;右 ，那就对应<strong>前序遍历构建</strong>嘛！</p>
<p>肯定是要用递归没错了，那再想每次递归要干什么？也就是对应到：构建每个节点，我们要做些什么？(1) 初始化该节点 (2) 确定该节点的左右孩子节点（此处说孩子节点其实有点不太恰当，应该是<strong>左右子树</strong>。</p>
<p>那下一步就是如何根据前序and中序结果确定根节点的值以及其左右子树的范围（因为左右子树的构建也是两棵二叉树的构建）。前序 &lt;-&gt; 根左右 、中序 &lt;-&gt; 左根右 、 后序 &lt;-&gt; 左右根。那前序结果中的第一个元素就是根节点嘛。确定了根节点再根据中序结果确定左右子树的范围，中序结果中的根节点左边的就是左子树，右边就是右子树嘛。剩下就递归构建咯嘿嘿！</p>
<h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><p><img src="/static/images/%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A01.jpg" alt="哦豁，没加载出来"></p>


  </article>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="busuanzi center">
    页阅读量:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    站访问量:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    站访客数:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>


    





    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © hhsdhh begin at 2022
    </div>
    <div class="secondrow">
        <a target="_blank" rel="noopener" href="https://github.com/gaoryrt/hexo-theme-pln">
        moments
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
